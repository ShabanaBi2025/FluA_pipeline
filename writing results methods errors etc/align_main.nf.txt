// main.nf (focus on ALIGN_INPUT)
nextflow.enable.dsl = 2

include { fastqc }      from './modules/qc.nf'
include { TRIMMOMATIC } from './modules/trimmomatic.nf'
include { NANOFILT }    from './modules/nanofilt.nf'
include { BWA_INDEX }   from './modules/bwa_index.nf'
include { ALIGN_ILLUMINA } from './modules/align_illumina.nf'
include { ALIGN_ONT }      from './modules/align_ont.nf'

workflow {

  // --- 1. Define Reference Genome Channel and Index ---
  Channel
    .from(params.references.entrySet())
    .map { entry -> tuple(entry.key, file(entry.value)) }
    .set { all_reference_fastas }

  indexed_references_channel = BWA_INDEX(all_reference_fastas)

  // Store indexed references in a map for easy lookup
  // This will collect all references into a single map (ref_id -> [fasta_file, ...])
  indexed_references_map = indexed_references_channel
    .mapTo(0) { it } // Map by the first element (ref_id)
    .collect() // Collect all into a single map
    .map { it } // Map the collected map to emit a single value
    .first() // Ensure it's a single value channel (map of ref_id -> (ref_id, fasta, amb, ...))
    .set { indexed_references_lookup_map } // This channel will emit one value: a map


  // --- 2. Create Raw Reads Channel - Grouping by Sample ID and Type ---
  Channel
    .fromPath(params.raw_reads)
    .map { file ->
            def strain_id = file.parent.name
            def filename = file.baseName
            def sample_id_clean = filename.replaceAll(/_R?[12]|\.fastq(.gz)?/, '')
            def platform_type
            if (filename.endsWith('_1') || filename.endsWith('_R1') ||
                filename.endsWith('_2') || filename.endsWith('_R2')) {
                platform_type = 'illumina'
            } else {
                platform_type = 'ont'
            }
            return tuple(strain_id, sample_id_clean, platform_type, file)
        }
        .groupTuple(by: [0, 1])
        .map { grouped_keys, platform_types_list, files_list ->
            def current_strain_id = grouped_keys.get(0)
            def current_sample_id_clean = grouped_keys.get(1)
            def final_platform_type = platform_types_list.get(0)
            def final_files = files_list
            if (final_platform_type == 'illumina') {
                final_files.sort { a, b -> a.name.compareTo(b.name) }
            }
            return tuple(current_sample_id_clean, final_platform_type, final_files, current_strain_id)
        }
        .set { all_raw_samples }

  fastqc_output = fastqc(all_raw_samples)

  qc_branched_output = fastqc_output
    .branch { sample_id, platform, reads, strain_id ->
      illumina: platform == 'illumina'
      ont:      platform == 'ont'
    }

  trimmed_illumina_output = TRIMMOMATIC(qc_branched_output.illumina)
  channel_for_align_illumina = trimmed_illumina_output
    .map { sample_id, platform, strain_id, paired1, unpaired1, paired2, unpaired2 ->
        tuple(sample_id, platform, [paired1, paired2], strain_id)
    }

  filtered_ont_reads = NANOFILT(qc_branched_output.ont)

  channel_for_align_ont = filtered_ont_reads
    .map { sample_id, platform, single_read, strain_id ->
      tuple(sample_id, platform, [single_read], strain_id)
    }

  final_reads_for_align = channel_for_align_illumina.mix(channel_for_align_ont)

  // --- 3. Lookup Indexed References and Pass to Aligners ---
  // We will now combine final_reads_for_align with the single-value indexed_references_lookup_map
  align_inputs = final_reads_for_align
    .combine(indexed_references_lookup_map) // Combine each read tuple with the single map of all references
    .map { sample_id, platform, reads_list, strain_id, all_refs_map ->
        // Lookup the specific reference details using the strain_id
        def specific_ref_data = all_refs_map.get(strain_id) // This gets the (ref_id, fasta, amb, ann, ...) tuple
        if (!specific_ref_data) {
            error "Reference for strain '$strain_id' not found in indexed references map."
        }
        def fasta_file = specific_ref_data.get(1) // Get fasta_file from the specific_ref_data tuple
        // Other index files (amb, ann, etc.) are at specific indices too.
        // Example: def amb = specific_ref_data.get(2)

        tuple(sample_id, platform, reads_list, fasta_file, strain_id) // Match ALIGNer input
    }
    .set { align_inputs_with_ref }


  // --- 4. Branch Aligned Inputs by Platform and Send to Specific Aligners ---
  align_inputs_with_ref
    .branch { sample_id, platform, reads_list, fasta_file, strain_id ->
      illumina_align: platform == 'illumina'
      ont_align:      platform == 'ont'
    }
    .set { align_branched_output }

  ALIGN_ILLUMINA(align_branched_output.illumina_align)
  ALIGN_ONT(align_branched_output.ont_align)

}